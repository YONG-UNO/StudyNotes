# 06.数组
## 1.数组的概念与定义
>数组是一种数据结构,用于存储一组**相同类型**的数据
数组中的元素在内存中是**连续**存放的
数组通过**下标**来访问元素,下标从0开始
```c
//下标从0开始
int arr[5] = {1,2,3,4,5};
```

## 2.数组的声明与初始化
>数组的声明
- 数组声明格式:**数组类型** **数组名** [**数组的大小**]
- 数组的大小必须是一个**正整数**
- 数组的大小不能为负数,且数组一旦声明了大小,**大小就不能改变**

```c
int a[10];  //合法,最常见的数组声明
int a[3+3];  //合法,3+3的结果是一个正确的正整数
#define X 10  int a[X];  //合法,X是一个符号常量
int n = 10, a[n]; //不合法,n是一个变量
```

>数组的初始化
- 全部初始化:
  ```c
  int arr[5] = {1,2,3,4,5};
- 部分初始化:
  ```c
  int arr[5] = {1,2};  //其余元素为0
- 没有初始化时,数组的默认值(通常为未定义)
```c 
int a[5] = {1,2,3,4,5};  //合法,完全初始化
int a[5] = {1,2,3};  //合法,部分初始化
int a[] = {1,2,3,4,5,6};  //合法,数组的大小由初始化元素个数决定
int a[5] = {1,2,3,4,5);  //不合法,初始化后面的括号应该是花括号
int a[5] = {1,2,3,4,5,6};  //不合法,初始化的元素个数大于数组本身大小
```

## **期末真题** 
>以下能对一堆数组a进行初始化的语句时:
```c
A、int a [5]=(0,1,2,3,4,);  //花括号
B、int a (5)={};  //中括号
C、int a [3]={0,1,2};
D、int a {5}={10*1};  //中括号
```
>在 C 语言中对一维整型数组的正确定义为 ( ) 。
```c
A、int a(10);  //中括号
B、int n=10,a[n];  //一定要是常量,而n是变量
C、int n;a[n];  //同上
D、#define N 10
   int a[N];
```

## 3.数组元素的访问
- 使用下标访问数组中的元素：array **[下标]**
- 下标是从**0**开始，并且下标是一个**整数**
- 下标越界将导致未定义行为
## 期末真题
>1.已知：int a[10]; 则对 a 数组元素的正确引用是:
```c
A、a[10] //下标最大为9
B、a[3.5]  //下标为整数
C、a(5)  //中括号
D、a[0]  
```

>2.若有以下数组说明，则 i=10;a [a [i]] 元素数值是：
```c
int a[12]={1,4,7,10,2,5,8,11,3,6,9,12};
A、10
B、9
C、6  //
D、5
```

## 4.二维数组
>- 二维数组可以看作是 “数组的数组”，即一个包含多个一维数组的数组。
>- 它用来表示矩阵或表格等二维数据。
>- 二维数组的声明格式：**数据类型** **数组名** **[行数][列数]**;
>- 二维数组的**初始化**
int arr[2][3] = {{1,2,3},{4,5,6}};  //合法，第一行的元素是 1，2，3，第二行的元素是 4，5，6
int arr[2][3] = {1,2,3,4,5,6};  //合法，第一行的元素是 1，2，3，第二行的元素是 4，5，6
int arr[2][3] = {1,2,3,4};  //合法，第一行的元素是 1，2，3，第二行的元素是 4，0，0
int arr[][3] = {1,2,3,4};  //合法，行数可以根据初始化元素个数推断出来
int arr[2][] = {1,2,3,4,5};  //不合法，**列数必须指定**

### 期末真题
>求一维数组a[10]中各元素的平均值，打印平均值，并输出小于平均值的元素
假定数组内容为:1.2  7  5  1.8  1.6  0.8  4  1.0  6  2.2
### 答案
```c
#include<stdio.h>

int main()
{
    float a[10] = {1.2,7,5,1.8,1.6,0.8,4,1.0,6,2.2}
    float sum = 0.0;
    float avg = 0.0;
    for(int i = 0; i < 10; i ++)
    {
        sum += a[i];
    }
    avg = sum / 10;
    for(int i = 0; i < 0; i++)
    {
        if a[i] < avg;
        prinf("%f\n",a[i]);
    }
}
```

# 07.指针Pointer
## 1.指针是什么
>指针是一个变量,用来存放内存地址的变量

指针的声明形式:
```c
int *p;
```
- p是指针变量的名称
- int*是一个类型,表示**指向整数的指针类型**
```c
int a = 10;
int *p = &a;
printf("%d",*p);
```
>- 1.int a = 10;声明整型变量a,初始化值为10;自动为变量分配一个存储空间来存放数值10
>- 2.int *p = &a;:声明指针变量p,类型为指向整型的指针(int *);&是取地址运算符,&a表示获取变量a的内存地址;本质:将变量a的地址赋值给指针变量p
>- 3.printf("%d",*p);:*是解引用运算符,对指针变量p进行解引用操作(*p),本质:通过指针p存储的地址,访问该地址所指向的内存单元中的值;p指向a,*p相当于a,因此printf函数输出a的值

>例子:
```c
#include <stdio.h>

int main() {
    int num = 10;  // 定义一个整型变量num，并初始化为10
    int *ptr = &num;  // 定义一个指向整型的指针变量ptr，并让它指向num的地址

    printf("变量num的值是：%d\n", num);
    printf("变量num的地址是：%p\n", &num);
    printf("指针变量ptr的名字是：ptr\n");
    printf("指针变量ptr的值（即它存储的地址）是：%p\n", ptr);
    printf("通过指针ptr解引用访问到的值是：%d\n", *ptr);

    return 0;
}

output:
变量num的值是：10
变量num的地址是：00000000005FFEC4
指针变量ptr的名字是：ptr
指针变量ptr的值（即它存储的地址）是：00000000005FFEC4
通过指针ptr解引用访问到的值是：10
```

## 2.一级指针&二级指针
> - 1.一级指针:存储的是变量的地址,通过解引用(*p)可以得到该变量的值
>- 2.二级指针:存储的是一级指针的地址,通过解引用(*pp)可以获得一级指针的值(即 **变量的地址**),再通过二次解引用(\**pp)可以获得**该变量的值**
```c
int a = 10;  //pp是一个二级指针变量
int *p = &a;  //*pp拿到的是指针变量p的值(变量a的地址)
int **pp = &p;  //**pp拿到的是变量a的值
```

## 3.指针和数值的关系
>数组名作为指针:在C语言中,数组名通常被看作是指向数组第一个元素的指针常量(地址)

```c
int arr[5] = {1,2,3,4,5}
int *p = arr;  //等同于 int *p = &arr[0];

printf("%d\n",*arr);  //输出10
printf("%d\n", *p)  //也输出10
```
>数组索引和指针算术本质是一样的
```c
int arr[5] = {1,2,3,4,5}

printf("%d",arr[2]);  //数组索引,输出30
printf("%d",*(arr + 2))  //使用指针算术
```
>数组名默认指向数组首元素的指针，可以将arr看作指向arr[0]的指针;指针算术运算中，arr + 2 表示在 arr 所指向的地址基础上，向后移动 2 个元素的位置。因为 arr 指向 arr[0]，arr + 1 就指向 arr[1]，arr + 2 则指向 arr[2]。
\* 是解引用操作符，*(arr + 2) 表示获取 arr + 2 所指向的内存位置的值。所以 *(arr + 2) 同样访问到了数组 arr 的第 3 个元素，其值也是 30，printf 函数同样会将这个值输出到控制台并换行。
总结来说，arr[2] 和 *(arr + 2) 这两种方式都能正确访问数组 arr 的第 3 个元素，只是一种是通过数组索引的方式，另一种是通过指针算术和解引用的方式，它们在效果上是等价的 ，都输出 30。


## 4.指针的算术运算
>指针&整数：当对指针进行加法时，实际上时移动指针所指向的内存位置，移动距离取决于指针类型
```c
int arr[]={1,2,3};
int *p = arr;

printf("%d",*p); 
printf("%d",*(p+1));  //指针位置后移四位（int类型占4个字节）
```

### 练习
>使用指针遍历数组
```c
#include <stdio.h>

int main()
{
    int arr[]={1,2,3,4};
    int len = sizeof(arr)/sizeof(int);
    for(int i = 0;i < len;i ++)
    {
        //printf("%d",arr[i]);
        printf("%d",*(arr+i));
        printf("\n");
    }
    return 0;
}
```
```c
int main()
{
  int a[]={10,20,30,40},*p=a+1;
  printf("%d\n",*p++);
printf("%d",++(*p));
}
#答案20 31
```
>1. **运算符优先级和结合性规则**
   - 在`printf("%d\n",*p++)`中，涉及到两个运算符：解引用运算符`*`和后置自增运算符`++`。根据C语言的运算符优先级和结合性规则，后置自增运算符`++`的优先级高于解引用运算符`*`，且后置自增运算符是自右向左结合的。
   - 当编译器遇到`*p++`时，它会先处理`p++`。因为是后置自增，所以它会先返回`p`当前的值（即指向`a[1]`，值为`20`的这个指针值），然后再对`p`进行自增操作（使`p`指向下一个元素`a[2]`）。
   - 接着，解引用运算符`*`作用于`p`之前返回的值，也就是`a[1]`，所以输出的是`a[1]`的值`20`，而不是对`20`进行加一操作。
2. **与前置自增运算符对比理解**
   - 如果是`*++p`，情况就不同了。这里是前置自增运算符`++`，它的优先级同样高于解引用运算符`*`，但前置自增是先对`p`进行自增操作（使`p`指向下一个元素），然后再进行解引用操作。
   - 例如，如果一开始`p`指向`a[1]`（值为`20`），对于`*++p`，`p`会先自增指向`a[2]`（值为`30`），然后`*`操作会取出`a[2]`的值`30`。
   - 而在`*p++`中，重点是后置自增的“先使用值，后自增”特性，导致了输出的是`p`自增前指向元素的值，而不是对该值进行算术运算。

所以，`printf("%d\n",*p++)`输出的是指针`p`自增前指向元素的值，而不是对该值进行加一的计算结果 ，这是由后置自增运算符的特性以及C语言运算符的优先级和结合性规则决定的。 

# 08.结构体，字符串，预处理
## 1.结构体
>结构体的定义与声明
![](.\images\2.png)

>结构体成员的访问
- a.通过点运算符(.)访问结构体的成员
**语法**：结构体变量.成员名
```c
// 定义结构体
struct Person{
  char name[10];
  int age;
  float height;
};    //;不要丢

int main(){
  //定义一个结构体变量并初始化
  struct Person person1 = {"张三"，20.=，1.6f}；

  //通过点运算符访问成员
  printf("Name: %s\n",person1.name);
  printf("Age: %d\n",person1.age);
  printf("Height: %.2f\n",person1.height);

  //修改结构体成员的值
  person1.age = 31;
  printf("Age: %d\n", person1.age);

  retrun 0;
}
```
- b.使用指针(指向符)(->)操作结构体成员
**语法**:结构体指针->成员名
```c
//定义结构体
struct Person {
  char name[50];
  int age;
  float height;
}; //;不要丢

int main(){
  //定义一个结构体变量并初始化
  struct Person person1 = {"张三",25,1.75f};

  //定义指向结构体的指针
  struct Person *personPtr = &person1;

  //通过箭头运算符访问成员
  printf("Name: %s\n",personPtr->name);
  printf("Age: %d\n",personPtr->age);
  printf("Height: %.2f\n",personPtr->height);

  \\修改结构体成员的值
  personPtr->age = 26;
  printf("Age: %d\n",personPtr->height);

  return 0;
}
```

>**题目**
对结构体变量stu1中成员age的非法引用是(B)
```c
struct student
{
  int age;
  int num;
}stu1,*p;
p = &stu1;

a.stu1.age
b.student.age
c.p->age
d.(*p).age
```

## 2.字符串的赋值
**正确**赋值
```c
char str[6] = "hello";
char str[] = "hello";
char str[6] = {"h","e","l","l","o","\0"};  //5个字符+1个结束符
char *str = "hello";  //定义字符指针,指向字符串"hello",字符串常量不可修改
```
**错误**赋值
```c
char str[5] = "hello";  //少了结束符
char str[6];str = "hello";  //数组名是一个常量指针，它指向数组的首地址，不能被重新赋值
```

## 3.预处理 #define
```c
#include <stdio.h>
#define ADD1(a,b) a+b
#define ADD2(a,b) (a+b)

int main()
{
  int a = 10;
  int b = 15;
  int ret1 = ADD1(a,b)*4;
  int ret2 = ADD(a,b)*4;
  printf("ret1的结果是: %d\n",ret1);
  printf("ret的结果是: %d\n",ret2);
  
  return 0;
}

//answer:10 + 15*4/ (10 + 15)*4
//if add():((a)+(b))more perfect ,because a could be an expression
```
> - 1.#define 是 C 语言中的预处理指令，用于宏定义。它的作用是在编译预处理阶段，将代码中出现的宏名替换为对应的宏体。
> - 2.#define ADD1(a,b) a+b：定义了一个名为 ADD1 的宏，它接受两个参数 a 和 b，宏体为 a+b。在预处理阶段，代码中出现的 ADD1(x,y) 形式的表达式，会被直接替换为 x+y 的形式。


